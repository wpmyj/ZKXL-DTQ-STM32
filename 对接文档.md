## 历史版本
| 版本 | 修改说明  |修改人|修改时间|
| :------| :------|:------:|:------|
|V0.1.0|1.初始版本|吴志涛|2017.03.18|
***
## 目录
[TOC]

***
## 1 文档说明
之前的对接一直使用的是**HEX格式**与友商对接，在对接的过程中发现这种方式效率比较低，需要花大量的时间讲解HEX的编码格式与编码及解码规则，为了方便对接，此特地使用**JSON格式**的数据来交互，由于他的简单与通用使对接过程变得极为高效。
答题器的DLL函数大致分为3类：
   * 绑定指令
   * 答题指令
   * 设置指令

***
## 2 答题器绑定相关API
答题器要与接收器通讯需要首先绑定一下，在绑定的过程中答题器与接收器会完成**设备ID（UID）**的交换，并且会将通讯过程中的参数写入到答题器。其中绑定的交互图如下：
```sequence
电脑端软件->接收器: 【1】发送清除白名单指令
Note over 接收器: 清除白名单
接收器-->>电脑端软件: 【2】返回清除操作的结果
电脑端软件->接收器: 【3】发送开始绑定指令
Note over 接收器: 打开13.56MHz刷卡模块
接收器-->>电脑端软件: 【4】返回开启绑定的结果
答题器->接收器: 【5】答题器贴近接收器刷卡区
接收器->答题器: 【6】写入绑定数据
电脑端软件->接收器: 【7】发送停止绑定指令
Note over  接收器: 关闭13.56MHz刷卡模块
接收器-->>电脑端软件: 【8】返回停止绑定的结果
```
上述过程所使用的指令 ，按照先后顺序仅列出**上位机与接收器**之间的交互指令，**注释中的指令序号为交互图对应的序号**：
* 指令序号【1】.清除白名单
```
{
    'fun':    'clear_wl'
}
```
* 指令序号【2】返回清除操作的结果

```
{
   'result':    '0'
}
```
* API函数申明及返回
```
int clear_wl();
int reslut  = clear_wl();
// reslut ==  0 表示操作成功
// result == -1 表示操作失败
```
**说明**：后面的**result**的含义于此处一致，便不再赘述。
>  0：表示成功
> -1：表示失败

* 指令序号【3】发送开始绑定指令
```
{
    'fun':    'bind',
    'cmd':     'start'
}
```
* 指令序号【4】返回开启绑定的结果
```
{
   'result':    '0'
}
```
* API函数申明及返回
```
int bind_start();
int result = bind_start();
// reslut ==  0 表示操作成功
// result == -1 表示操作失败
```

* 指令序号【7】发送停止绑定指令
```
{
    'fun':    'bind',
    'cmd':     'stop'
}
```
* 指令序号【8】返回开启绑定的结果
```
 {
   'result':    '0'
}
```
* API函数申明及返回
```
int bind_stop();
int result = bind_stop();
// reslut ==  0 表示操作成功
// result == -1 表示操作失败
```

***
## 3 答题指令
### 3.1简单工作模式 
这种工作方式比较简单，只用发送一次题目，这个样接收器一致处于监听状态，答题器之后随时都能提交答案，此时相当答题器与接收器没有交互过程，仅仅是由答题器发送答案到接收器。这个有上位机软件根据**答题器提交答案的时间**判断答案是对应的那个题目。

### 3.2 普通工作模式（推荐用法）
这种工作方式是我们推荐的工作方式，这种方式每次作答时都需要重新发送题目，之后才允许作答。

不管哪种工作方式对应得程序交互图如下：
```sequence
电脑端软件->接收器: 【1】发送题目指令
接收器-->>电脑端软件: 【2】返回发送题目操作的结果
接收器->答题器: 【3】发送题目指令
答题器-->>接收器: 【4】返回接收指令的结果
答题器->接收器: 【5】发送题目答案
Note over  接收器:缓存答题器答案
接收器-->答题器: 【6】返回答题器提交答案结果
电脑端软件->接收器: 【7】获取答题器题目答案
接收器-->>电脑端软件: 【8】返回发答题器提交的结果
Note over  接收器:清除答案缓存
电脑端软件->接收器: 【9】发送停止作答
Note over  接收器:关闭接收器接收答案功能
接收器-->>电脑端软件: 【10】返回停止作答指令的执行结果
```
**注意：普通工作方式每次换题目需要从一号指令重头再来一遍；简单工作方式则只用从5到10号指令循环**。
上述过程所使用的指令 ，按照先后顺序仅列出**上位机与接收器**之间的交互指令，**注释中的指令序号为交互图对应的序号**：
* 指令序号【1】发送题目指令
```
{
    'fun':    'start',
    'time':   '2017-02-15:17:41:07'
    'num':    '4',
    't1':    'x1',
    'q1':    'y1',
    'a1':    'z1',
    ...
    'tn':    'xn',
    'qn':    'yn',
    'an':    'zn',
}
```
**说明**：此处的*num*表示题目的数量，后面的*tn*与*qn*分别表示第道题目的题型喻作答范围
>time：发送题目时间
>num：题目数，最大支持70道题目
>tn    ：题目类型
>> 1 : 表示单选；
>> 2 : 表示多选；
>> 3 : 表示判断;
>> 4 : 表示数字;

>qn   ：题号
>an   ：作答范围，例如4表示A~D 如果是6表示A~F

* 指令序号【2】返回发送题目操作的结果
```
 {
   'result':    '0'
}
```

* API函数申明及返回
```
int  answer_start(int num, char *str);
int result = answer_start(num1,str1);
// reslut ==  0 表示操作成功
// result == -1 表示操作失败
```
**说明**：此处的*num*表示题目的数量，str为指向题目信息的指针
>num：题目数，最大支持70道题目
>str：题目信息的指针
>>  题目信息3个byte为一组，第一个为题目类型，后面一个为题目类型

 例如下发送4道题目的参数如下:
| 类型 |转换编码|题号|转换编码 |作答范围|转换编码|
| :------| :------:|:------:| :------| :------:|:------:|
| 单选|0x01| 1|0x01|A~D|0x0F|
| 多选|0x02| 2|0x02|A~F|0x07F|
| 判断|0x03| 3|0x03|对或错|0x03|
| 评分|0x04| 4|0x04|1~5|0x1F|
则对应的参数如下：
> num = 4
> str = { 0x01, 0x01, 0x0F, 0x02, 0x02, 0x7F, 0x03, 0x03, 0x03, 0x04, 0x04, 0x1F }

* 指令序号【7】获取答题器题目答案
```
 {
   'fun':    'getlist'
}
```
* 指令序号【8】返回发答题器提交的结果
```
 [{
   'RoleTypeName': '学生',
   'DeviceTypeName':  '交互卡',
   'CardID':  '2107854592',
   'UpdateTime':  '2017\02\15 17:41:17 ',
   'AnswerTypeName':  '多选题',
   'q1':  'AB'
}]
```
* API函数申明及返回
```
char * getlist();
char *str = getlist();
// str = 
// [{
//    'RoleTypeName': '学生',
//    'DeviceTypeName':  '交互卡',
//    'CardID':  '2107854592',
//    'UpdateTime':  '2017\02\15 17:41:17 ',
//    'AnswerTypeName':  '多选题',
//    'q1':  'AB'
// }]
```
* 指令序号【9】发送停止作答
```
 {
   'fun':    'stop'
}
```
* 指令序号【10】返回停止作答指令的执行结果
```
 {
   'result':    '0'
}
```
* API函数申明及返回
```
int answer_stop();
int result = answer_stop();
// reslut ==  0 表示操作成功
// result == -1 表示操作失败
```
***
## 4 设置指令
### 4.1 理论说明
设置指令是配置答题器参数的指令，主要操作是答题器上面的一块标签芯片，设置参数就是往这块标签中写入数据，答题器开机的时候会读取这个里面的设这参数，来调整自己的通讯参数，下面描述一下答题器13.56Mhz标签的空间分配：
| LEN| UID |UPOS|TX_CH|RX_CH|TX_POWER|REV|STDID|
| :------:| :------|:------:|:------:|:------:|:------:|:------:|:------:|
|2         |4       |2        |1       |1        |1       |2        |    10|
**说明**:下面是字段的含义
- LEN:配置数据长度
- UID:接收器的UID
- UPOS:接收器在绑定答题器的过程中分配的序号
-  TX_CH:答题器发送数据的信道
-  RX_CH:答题器接收数据的信道
-  TX_POWER:答题器发送数据的发送功率
-  REV:保留字段
- STDID:学生身份信息ID
### 4.2 答题器设置学号相关API
设置答题器的学号与绑定的过程比较相似，都是通过刷卡完成，对用的时序图如下：
```sequence
电脑端软件->接收器: 【1】设置学号指令
Note over 接收器: 打开13.56MHz刷卡模块
答题器->接收器: 【2】答题器贴近接收器刷卡区
接收器->答题器: 【3】写入学号数据
Note over  接收器: 关闭13.56MHz刷卡模块
接收器-->>电脑端软件: 【4】返回停止绑定的结果
```
上述过程所使用的指令 ，按照先后顺序仅列出**上位机与接收器**之间的交互指令，**注释中的指令序号为交互图对应的序号**：
* 指令【1】设置学号指令
```
{
    'fun':    'set_student_id',
    'student_id':     '2017031234'
}
```
* 指令【4】返回答题器id与写入学号id
```
{
   'card_id':    'xxxxxxx'，
    'student_id':     '2017031234'
}
```
* API函数申明及返回
```
char * set_student_id(char *str);
char *stdid;
stdid = set_student_id(str1);
//stdid = 
//{
//   'card_id':    'xxxxxxx'，
//    'student_id':     '2017031234'
//}
```

**说明:答题器的 *开启绑定* 与 *写入学号* 的关系**：
* 绑定过程无需参数，发送一条绑定指令可以就可以完成所有答题器的绑定,写入学号则**只能**写入一个答题器。所以绑定需要有一条停止指令，而写入学号不需要。
* **写入学号**与**开启绑定**都是占用13.56Mhz的刷卡的硬件资源，所以无法在开启绑定的情况下执行写入学号指令。
* 如果使用接收器向没有绑定自己的答题器写入学号，则在写入学号的过程中**自动完成**绑定。
* 如果在本机上已经绑定的答题器，写入学号，则**原绑定信息不变**。
* 已经写入学号的答题器绑定到新的接收器会**清除**原来的学号信息。

### 4.3 答题器设置通讯参数相关API
 答题器在与接收器通讯的过程中有一些关键参数有可能需要修改，比如信道和发送功率等，设置的这些参数对通讯是否成功至关重要。
**注意：这些参数是在答题器贴近接收器刷卡区的过程中写入到答题器的。**
* 指令【1】设置信道指令
```
{
    'fun':    'set_channel',
    'tx':     '2'，
    'rx':     '4'
}
```
* 指令【2】设置信道指令返回
```
 {
   'result':    '0'
}
```
* API函数申明及返回
```
int set_channel(int tx_ch,int rx_ch);
int result = set_channel(ch1,ch2);
// reslut ==  0 表示操作成功
// result == -1 表示操作失败
```

**说明**：这条指令是用来设置答题器与接收的通选信道的，有的时候为了避免干扰，需要修改答题器与接收器的信道。
>tx    ：答题器的发送信道，范围1~11
>rx   ：答题器的接收信道，范围1~11

* 指令【1】设置发送功率指令
```
{
    'fun':    'set_tx_power',
    'power':     '4'，
}
```
* 指令【2】设置发送功率指令返回
```
 {
   'result':    '0'
}
```
**说明**：这条指令是用来设置答题器的发送功率，我们答题器默认是+4DB发送的，有时候这个功率是比较大的，当应该场景不需要这么大的功率时，我们可以使用这个接口修改发送功率。
>power    ：答题器的发送功率，范围-30~+4, 参数必须是偶数

* API函数申明及返回
```
int set_tx_power(int power);
int result = set_tx_power( power1);
// reslut ==  0 表示操作成功
// result == -1 表示操作失败
```
### 4.3 其它API
* 指令【1】查询设备信息
```
{
    'fun':    'get_device_no'
}
```
* 指令【2】查询设备信息指令返回
``` 
 {
    'DeviceId': '3633897184',
    'softwareVersion':  'v0.1.0 ',
    'HardwareVersion':  'ZL\RP551\MAIN\E'
    'Company':  '讯联股份'
}
```
* API函数申明及返回
```
char *decvice_info;
decvice_info = get_device_info();
//decvice_info =
//{
//    'DeviceId': '3633897184',
//    'softwareVersion':  'v0.1.0 ',
//    'HardwareVersion':  'ZL\RP551\MAIN\E'
//    'Company':  '讯联股份'
//}
```



